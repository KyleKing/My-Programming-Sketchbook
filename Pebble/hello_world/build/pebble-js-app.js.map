{"version":3,"sources":["webpack/bootstrap 8c52b900b17c2516f031","/Users/kyleking/Library/Application Support/Pebble SDK/SDKs/4.3/sdk-core/pebble/common/include/_pkjs_shared_additions.js","/Users/kyleking/Library/Application Support/Pebble SDK/SDKs/4.3/sdk-core/pebble/common/include/_pkjs_message_wrapper.js","/Users/kyleking/Library/Application Support/Pebble SDK/SDKs/4.3/~/utf8/utf8.js","(webpack)/buildin/module.js","./src/pkjs/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA,EAAC;;;;;;;ACnBD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,uBAAsB,QAAQ,EAAE;AAChC,yBAAwB,4BAA4B,EAAE;AACtD;AACA,QAAO;AACP;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;;AAEA;AACA;AACA,gBAAe;AACf;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+DAA8D;AAC9D,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,yBAAyB;AAC9C;AACA;AACA,oBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6DAA4D;AAC5D,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,uBAAuB;AACtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,sDAAsD;AAC/E;;AAEA;AACA,0BAAyB,6BAA6B;AACtD;;AAEA;AACA,0BAAyB,iCAAiC;AAC1D;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,0EAAyE;AACzE,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+EAA8E;AAC9E;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH,EAAC;;;;;;;mCChrBD;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,MAAK;AACL,6BAA4B;AAC5B;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAsC;AACtC;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAEA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF,oBAAmB;AACnB;AACA,IAAG,OAAO;AACV;AACA;AACA;AACA;AACA;AACA;AACA,GAAE,OAAO;AACT;AACA;;AAEA,EAAC;;;;;;;;ACnPD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;AACL;AACA,MAAK;AACL,MAAK,oCAAoC;AACzC,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pebble-js-app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8c52b900b17c2516f031","(function(p) {\n  if (!p === undefined) {\n    console.error('Pebble object not found!?');\n    return;\n  }\n\n  // Aliases:\n  p.on = p.addEventListener;\n  p.off = p.removeEventListener;\n\n  // For Android (WebView-based) pkjs, print stacktrace for uncaught errors:\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('error', function(event) {\n      if (event.error && event.error.stack) {\n        console.error('' + event.error + '\\n' + event.error.stack);\n      }\n    });\n  }\n\n})(Pebble);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/kyleking/Library/Application Support/Pebble SDK/SDKs/4.3/sdk-core/pebble/common/include/_pkjs_shared_additions.js\n// module id = 1\n// module chunks = 0","(function() {\n  var utf8 = require('utf8');\n  var POSTMESSAGE_DEBUG = false;\n\n  // Super simple polyfill for Array.from() that only deals with a Uint8Array:\n  var arrayFromUint8Array = Array.from ? Array.from : function(uint8Array) {\n      return [].slice.call(uint8Array);\n  };\n\n  function debugLog() {\n    if (POSTMESSAGE_DEBUG) {\n      console.log.apply(console, arguments);\n    }\n  }\n\n  function createHandlersList() {\n    var pos = 0;\n    var handlers = [];\n\n    return {\n      add : function(handler) {\n        handlers.push(handler);\n      },\n      clear : function() {\n        handlers = [];\n        pos = 0;\n      },\n      isEmpty : function() {\n        return (handlers.length == 0);\n      },\n      remove : function(handler) {\n        var idx = handlers.indexOf(handler);\n        if (idx < 0) { return; } // Not registered\n        if (idx < pos) { pos = Math.max(pos - 1, 0); } // We've iterated past it, and it's been removed\n        handlers.splice(idx, 1);\n      },\n      newIterator : function() {\n        pos = 0; // new iterator, reset position\n        return {\n          next : function() {\n            if (pos < handlers.length) {\n              return handlers[pos++];\n            } else {\n              return undefined;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var EVENTS = {};\n\n  var _callHandler = function(handler, event_name, callback_data) {\n    var msg = { type: event_name };\n    if (callback_data !== undefined) {\n      msg.data = callback_data;\n    }\n    handler(msg);\n  };\n\n  var _callHandlersForEvent = function(event_name, callback_data) {\n    var handler;\n    if (!(event_name in EVENTS)) {\n      return;\n    }\n\n    var it = EVENTS[event_name].newIterator();\n    while ((handler = it.next())) {\n      _callHandler(handler, event_name, callback_data);\n    }\n  }\n\n  var _isPostMessageEvent = function(event_name) {\n    return (['message', 'postmessageerror',\n             'postmessageconnected', 'postmessagedisconnected'].indexOf(event_name)) > -1;\n  }\n\n  var __Pebble = Pebble;\n\n  // Create a new object with its prototype pointing to the original, using\n  // Object.create(). This way, we can rely on JavaScript's prototype chain\n  // traversal to make all properties on the original object \"just work\".\n  // Note however, that these won't be \"own properties\", so when using\n  // `for .. in`, Pebble.keys(), Object.getOwnPropertyNames(), etc. these\n  // \"delegated properties\" will not be found.\n  Pebble = Object.create(Pebble);\n\n  for (var attr in __Pebble) {\n    if (!__Pebble.hasOwnProperty(attr)) {\n      continue;\n    }\n    // Attributes of Pebble which can be bound, should be bound to the original object\n    if (__Pebble[attr].bind) {\n      Pebble[attr] = __Pebble[attr].bind(__Pebble);\n    } else {\n      Pebble[attr] = __Pebble[attr];\n    }\n  }\n\n  // Ensure that all exported functions exist.\n  [\"addEventListener\", \"removeEventListener\", \"showSimpleNotificationOnPebble\",\n   \"sendAppMessage\", \"getTimelineToken\", \"timelineSubscribe\",\n   \"timelineUnsubscribe\", \"timelineSubscriptions\", \"getActiveWatchInfo\",\n   \"getAccountToken\", \"getWatchToken\", \"appGlanceReload\"].forEach(\n      function(elem, idx, arr) {\n        if ((elem in Pebble) || ((typeof __Pebble[elem]) !== 'function')) {\n          // This function has already been copied over or doesn't actually exist.\n          return;\n        }\n        Pebble[elem] = __Pebble[elem].bind(__Pebble);\n      }\n   );\n\n  // sendAppMessage is not supported, make it undefined so a user will get a\n  // \"not a function\" error, and can check `typeof Pebble.sendAppMessage === 'function'`\n  // to test for support.\n  Pebble[\"sendAppMessage\"] = undefined;\n\n  // The rocky implementation!\n\n  function _scheduleAsyncPostMessageError(jsonString, reason) {\n    _callHandlersForEvent('postmessageerror', JSON.parse(jsonString));\n    console.error(\"postMessage() failed. Reason: \" + reason);\n  }\n\n  Pebble.postMessage = function(obj) {\n    _out.sendObject(obj);\n  };\n\n  var on = function(event_name, handler) {\n    if (typeof(handler) !== 'function') {\n      throw TypeError(\"Handler for event expected, received \" + typeof(handler));\n    }\n    if (!(event_name in EVENTS)) {\n      EVENTS[event_name] = createHandlersList();\n    }\n    EVENTS[event_name].add(handler);\n\n    if ((event_name == \"postmessageconnected\" && _control.state == ControlStateSessionOpen) ||\n        (event_name == \"postmessagedisconnected\" && _control.state != ControlStateSessionOpen)) {\n      _callHandler(handler, event_name);\n    }\n  };\n\n  Pebble.addEventListener = function(event_name, handler) {\n    if (_isPostMessageEvent(event_name)) {\n      return on(event_name, handler);\n    } else if (event_name == 'appmessage') {\n      throw Error(\"App Message not supported with Rocky.js apps. See Pebble.postMessage()\");\n    } else {\n      return __Pebble.addEventListener(event_name, handler);\n    }\n  };\n\n  // Alias to the overridden implementation:\n  Pebble.on = Pebble.addEventListener;\n\n  var off = function(event_name, handler) {\n    if (handler === undefined) {\n      throw TypeError('Not enough arguments (missing handler)');\n    }\n    if (event_name in EVENTS) {\n      EVENTS[event_name].remove(handler);\n    }\n  }\n\n  Pebble.removeEventListener = function(event_name, handler) {\n    if (_isPostMessageEvent(event_name)) {\n      off(event_name, handler);\n    } else {\n      return __Pebble.removeEventListener(event_name, handler);\n    }\n  }\n\n  // Alias to the overridden implementation:\n  Pebble.off = Pebble.removeEventListener;\n\n  /*********************************************************************************\n   * postMessage(): Outbound object and control message queuing, sending & chunking.\n   ********************************************************************************/\n\n  var _out = new Sender();\n\n  function Sender() {\n    this.controlQueue = [];\n    this.objectQueue = [];\n\n    this._currentMessageType = undefined;\n    this._failureCount = 0;\n    this._offsetBytes = 0;\n    this._chunkPayloadSize = 0;\n\n    this._resetCurrent = function() {\n      this._currentMessageType = undefined;\n      this._failureCount = 0;\n      this._offsetBytes = 0;\n      this._chunkPayloadSize = 0;\n    };\n\n    this._getNextMessageType = function() {\n      if (this.controlQueue.length > 0) {\n        return \"control\";\n      } else if (this.objectQueue.length > 0) {\n        return \"object\";\n      }\n      // No messages remaining\n      return undefined;\n    };\n\n    // Begin sending the next prioritized message\n    this._sendNext = function() {\n      if (this._currentMessageType !== undefined) {\n        return; // Already something in flight\n      }\n\n      var type = this._getNextMessageType();\n      if (type === undefined) {\n        return; // No message to send\n      }\n\n      if (type === \"control\") {\n        this._currentMessageType = type;\n        this._trySendNextControl();\n      } else if (type === \"object\") {\n        this._currentMessageType = type;\n        this._trySendNextChunk();\n      }\n    };\n\n\n    //////////////////////////////////////////////////////////////////////////////\n    // Sender: Control Message Handling\n    //////////////////////////////////////////////////////////////////////////////\n\n    this._controlSuccess = function() {\n      this.controlQueue.shift();\n      this._resetCurrent();\n      this._sendNext();\n    };\n\n    this._controlFailure = function(e) {\n      this._failureCount++;\n      var willRetry = (this._failureCount <= 3);\n      if (willRetry) {\n        setTimeout(this._trySendNextControl.bind(this), 1000); // 1s retry\n      } else {\n        debugLog(\"Failed to send control message: \" + e +\n                 \", entering disconnected state.\");\n        this.controlQueue.shift();\n        this._resetCurrent();\n\n        _control.enter(ControlStateDisconnected);\n        this._sendNext();\n      }\n    };\n\n    this._trySendNextControl = function() {\n      var msg = this.controlQueue[0];\n      __Pebble.sendAppMessage(msg,\n                              this._controlSuccess.bind(this),\n                              this._controlFailure.bind(this));\n    };\n\n\n    //////////////////////////////////////////////////////////////////////////////\n    // Sender: Object Message Handling\n    //////////////////////////////////////////////////////////////////////////////\n\n    this._createDataObject = function(obj) {\n      // Store obj as UTF-8 encoded JSON string into .data:\n      var native_str_msg;\n      try {\n        native_str_msg = JSON.stringify(obj);\n      } catch(e) {\n        throw Error(\"First argument must be JSON-serializable.\");\n      }\n      // ECMA v5.1, 15.12.3, Note 5: Values that do not have a JSON\n      // representation (such as undefined and functions) do not produce a\n      // String. Instead they produce the undefined value.\n      if (native_str_msg === undefined) {\n        throw TypeError(\n          \"Argument at index 0 is not a JSON.stringify()-able object\");\n      }\n      var utf8_str_msg = utf8.encode(native_str_msg);\n      var data = [];\n      for (var i = 0; i < utf8_str_msg.length; i++) {\n        data.push(utf8_str_msg.charCodeAt(i));\n      }\n      data.push(0);  // zero-terminate\n\n      return {\n        obj: obj,\n        data: data,\n        json: native_str_msg,\n      };\n    };\n\n    this._completeObject = function(failureReasonOrUndefined) {\n      var completeObject = this.objectQueue.shift();\n      this._resetCurrent();\n\n      if (failureReasonOrUndefined === undefined) {\n        debugLog(\"Complete!\");\n      } else {\n        _scheduleAsyncPostMessageError(completeObject.json, failureReasonOrUndefined);\n      }\n    };\n\n    this._chunkSuccess = function(e) {\n      var data = this.objectQueue[0].data;\n      debugLog(\"Sent \" + this._chunkPayloadSize + \" of \" + data.length + \" bytes\");\n      this._offsetBytes += this._chunkPayloadSize;\n      if (this._offsetBytes === data.length) {\n        this._completeObject();\n        this._sendNext();\n      } else {\n        this._trySendNextChunk();\n      }\n    };\n\n    this._chunkFailure = function(e) {\n      this._failureCount++;\n      var willRetry = (this._failureCount <= 3);\n      console.error(\"Chunk failed to send (willRetry=\" + willRetry + \"): \" + e);\n      if (willRetry) {\n        setTimeout(this._trySendNextChunk.bind(this), 1000); // 1s retry\n      } else {\n        this._completeObject(\"Too many failed transfer attempts\");\n        this._sendNext();\n      }\n    };\n\n    this._trySendNextChunk = function() {\n      if (this._getNextMessageType() !== \"object\") {\n        // This is no longer our highest priority outgoing message.\n        // Send that message instead, and this message will be left in the queue\n        // andrestarted when appropriate.\n        this._resetCurrent();\n        this._sendNext();\n        return;\n      }\n\n      if (!_control.isSessionOpen()) {\n        // Make sure to start over if session is closed while chunks have been\n        // sent for the head object:\n        this._offsetBytes = 0;\n        this._chunkFailure(\"Session not open. Hint: check out the \\\"postmessageconnected\\\" event.\");\n        return;\n      }\n\n      var data = this.objectQueue[0].data;\n      var sizeRemaining = data.length - this._offsetBytes;\n      debugLog(\"Sending next chunk, sizeRemaining: \" + sizeRemaining);\n      this._chunkPayloadSize =\n        Math.min(_control.protocol.tx_chunk_size, sizeRemaining);\n      var n;\n      var isFirst = (this._offsetBytes === 0);\n      var isFirstBit;\n      if (isFirst) {\n        isFirstBit = (1 << 7);\n        n = data.length;\n      } else {\n        isFirstBit = 0;\n        n = this._offsetBytes;\n      }\n      var chunk = [\n        n & 255,\n        (n >> 8) & 255,\n        (n >> 16) & 255,\n        ((n >> 24) & ~(1 << 7)) | isFirstBit\n      ];\n      var chunkPayload = data.slice(\n        this._offsetBytes, this._offsetBytes + this._chunkPayloadSize);\n      Array.prototype.push.apply(chunk, chunkPayload);\n      debugLog(\"Sending Chunk Size: \" + this._chunkPayloadSize);\n      __Pebble.sendAppMessage({ControlKeyChunk: chunk},\n        this._chunkSuccess.bind(this),\n        this._chunkFailure.bind(this));\n    };\n\n    //////////////////////////////////////////////////////////////////////////////\n    // Sender: Public Interface\n    //////////////////////////////////////////////////////////////////////////////\n\n    this.sendObject = function(obj) {\n      debugLog(\"Queuing up object message: \" + JSON.stringify(obj));\n      var dataObj = this._createDataObject(obj);\n      this.objectQueue.push(dataObj)\n      this._sendNext();\n    };\n\n    this.sendControl = function(obj) {\n      debugLog(\"Sending control message: \" + JSON.stringify(obj));\n      this.controlQueue.push(obj);\n      this._sendNext();\n    }\n  };\n\n  /*****************************************************************************\n   * postMessage(): Receiving chunks of inbound objects and reassembly\n   ****************************************************************************/\n\n  var _in = new ChunkReceiver();\n\n  function ChunkReceiver() {\n    this.utf8_json_string = \"\";\n    this.total_size_bytes = 0;\n    this.received_size_bytes = 0;\n\n    this.handleChunkReceived = function handleChunkReceived(chunk) {\n      if (!chunk) {\n        return false;\n      }\n      var isExpectingFirst = (this.utf8_json_string.length === 0);\n      if (chunk.is_first != isExpectingFirst) {\n        console.error(\n          \"Protocol out of sync! chunk.is_first=\" + chunk.is_first +\n          \" isExpectingFirst=\" + isExpectingFirst);\n        return false;\n      }\n      if (chunk.is_first) {\n        this.total_size_bytes = chunk.total_size_bytes;\n        this.received_size_bytes = 0;\n      } else {\n        if (this.received_size_bytes != chunk.offset_bytes) {\n          console.error(\n            \"Protocol out of sync! received_size_bytes=\" +\n            this.received_size_bytes + \" chunk.offset_bytes=\" + chunk.offset_bytes);\n          return false;\n        }\n        if (this.received_size_bytes + chunk.data.length > this.total_size_bytes) {\n          console.error(\n            \"Protocol out of sync! received_size_bytes=\" + this.received_size_bytes +\n            \" chunk.data.length=\" + chunk.data.length +\n            \" total_size_bytes=\" + this.total_size_bytes);\n          return false;\n        }\n      }\n\n      debugLog(\"Received (\" + this.received_size_bytes + \" / \" +\n        this.total_size_bytes + \" bytes)\");\n      debugLog(\"Payload size: \" + chunk.data.length);\n\n      this.received_size_bytes += chunk.data.length;\n      var isLastChunk = (this.received_size_bytes == this.total_size_bytes);\n      var isLastChunkZeroTerminated = undefined;\n      if (isLastChunk) {\n        isLastChunkZeroTerminated = (chunk.data[chunk.data.length - 1] === 0);\n      }\n\n      // Copy the received data over:\n      var end = isLastChunk ? chunk.data.length - 1 : chunk.data.length;\n      for (var i = 0; i < end; i++) {\n        this.utf8_json_string += String.fromCharCode(chunk.data[i]);\n      }\n\n      if (isLastChunk) {\n        if (isLastChunkZeroTerminated) {\n          var json_string = utf8.decode(this.utf8_json_string);\n          var data;\n          try {\n            data = JSON.parse(json_string);\n          } catch (e) {\n            console.error(\n              \"Dropping message, failed to parse JSON with error: \" + e +\n              \" (json_string=\" + json_string + \")\");\n          }\n          if (data !== undefined) {\n            _callHandlersForEvent('message', data);\n          }\n        } else {\n          console.error(\"Last Chunk wasn't zero terminated! Dropping message.\");\n        }\n\n        this.utf8_json_string = \"\";\n      }\n\n      return true;\n    }\n  }\n\n  /*****************************************************************************\n   * postMessage() Session Control Protocol\n   ****************************************************************************/\n\n  var ControlStateDisconnected = \"ControlStateDisconnected\";\n  var ControlStateAwaitingResetCompleteRemoteInitiated = \"ControlStateAwaitingResetCompleteRemoteInitiated\";\n  var ControlStateAwaitingResetCompleteLocalInitiated = \"ControlStateAwaitingResetCompleteLocalInitiated\";\n  var ControlStateSessionOpen = \"ControlStateSessionOpen\";\n\n  var ControlKeyResetRequest = \"ControlKeyResetRequest\";\n  var ControlKeyResetComplete = \"ControlKeyResetComplete\";\n  var ControlKeyChunk = \"ControlKeyChunk\";\n  var ControlKeyUnsupportedError = \"ControlKeyUnsupportedError\";\n\n  function _unpackResetCompleteMessage(data) {\n    debugLog(\"Got ResetComplete: \" + data);\n    return {\n      min_version : data[0],\n      max_version : data[1],\n      max_tx_chunk_size : (data[2] << 8) | (data[3]),\n      max_rx_chunk_size : (data[4] << 8) | (data[5]),\n    };\n  };\n\n  function _unpackChunk(data) {\n    //debugLog(\"Got Chunk: \" + data);\n    if (data.length <= 4) {\n      console.error(\"Chunk data too short to be valid!\");\n      return;\n    }\n    var is_first_bit = (1 << 7);\n    var is_first = (is_first_bit === (data[3] & is_first_bit));\n    var chunk = {\n      is_first : is_first\n    };\n    var msbyte = (~is_first_bit) & data[3];\n    var num31bits = (msbyte << 24) | (data[2] << 16) | (data[1] << 8) | data[0];\n    if (is_first) {\n      chunk.total_size_bytes = num31bits;\n    } else {\n      chunk.offset_bytes = num31bits;\n    }\n    chunk.data = data.slice(4);\n    return chunk;\n  }\n\n  function _remoteProtocolValidateAndSet(remote) {\n    debugLog(\"Remote min: \" + remote.min_version);\n    debugLog(\"Remote max: \" + remote.max_version);\n    if (remote.min_version == undefined || remote.max_version == undefined ||\n        remote.min_version > PROTOCOL.max_version || remote.max_version < PROTOCOL.min_version) {\n      return false;\n    }\n\n    _control.protocol = {\n      version : Math.min(remote.max_version, PROTOCOL.max_version),\n      tx_chunk_size : Math.min(remote.max_rx_chunk_size, PROTOCOL.max_tx_chunk_size),\n      rx_chunk_size : Math.min(remote.max_tx_chunk_size, PROTOCOL.max_rx_chunk_size),\n    };\n\n    return true;\n  };\n\n  function _sendControlMessage(msg) {\n    _out.sendControl(msg);\n  }\n\n  function _controlSendResetComplete() {\n    var data = new Uint8Array(6);\n    data[0] = PROTOCOL.min_version;\n    data[1] = PROTOCOL.max_version;\n    data[2] = PROTOCOL.max_tx_chunk_size >> 8;\n    data[3] = PROTOCOL.max_tx_chunk_size;\n    data[4] = PROTOCOL.max_rx_chunk_size >> 8;\n    data[5] = PROTOCOL.max_rx_chunk_size;\n    _sendControlMessage({ ControlKeyResetComplete : arrayFromUint8Array(data) });\n  }\n\n  function _controlSendResetRequest() {\n    _sendControlMessage({ ControlKeyResetRequest : 0 });\n  }\n\n  function _controlSendUnsupportedError() {\n    _sendControlMessage({ ControlKeyUnsupportedError : 0 });\n  }\n\n  var ControlHandlers = {\n    ControlStateDisconnected : function(payload) {\n    },\n    ControlStateAwaitingResetCompleteRemoteInitiated : function(payload) {\n      if (ControlKeyResetComplete in payload) {\n        var remote_protocol = _unpackResetCompleteMessage(payload[ControlKeyResetComplete]);\n        // NOTE: This should *always* be true, we should never receive a\n        // ResetComplete response from the Remote in this state since it already\n        // knows it is unsupported\n        if (_remoteProtocolValidateAndSet(remote_protocol)) {\n          _control.enter(ControlStateSessionOpen);\n        }\n      } else if (ControlKeyResetRequest in payload) {\n        _control.enter(ControlStateAwaitingResetCompleteRemoteInitiated); // Re-enter this state\n      } else if (ControlKeyChunk in payload) {\n        _control.enter(ControlStateAwaitingResetCompleteLocalInitiated);\n      } else if (ControlKeyUnsupportedError in payload) {\n        throw Error(\"Unsupported protocol error: \" + payload[ControlKeyUnsupportedError]);\n      }\n    },\n    ControlStateAwaitingResetCompleteLocalInitiated : function(payload) {\n      if (ControlKeyResetComplete in payload) {\n        var remote_protocol = _unpackResetCompleteMessage(payload[ControlKeyResetComplete]);\n        debugLog(\"Remote Protocol: \" + remote_protocol);\n        if (_remoteProtocolValidateAndSet(remote_protocol)) {\n          debugLog(\"OK Remote protocol...\");\n          _controlSendResetComplete();\n          _control.enter(ControlStateSessionOpen);\n        } else {\n          _controlSendUnsupportedError();\n        }\n      } else {\n        ; // Ignore, we're in this state because we already sent a ResetRequest\n      }\n    },\n    ControlStateSessionOpen : function(payload) {\n      if (ControlKeyChunk in payload) {\n        var chunk = _unpackChunk(payload[ControlKeyChunk]);\n        if (false === _in.handleChunkReceived(chunk)) {\n          _control.enter(ControlStateAwaitingResetCompleteLocalInitiated);\n        }\n      } else if (ControlKeyResetRequest in payload) {\n        _control.enter(ControlStateAwaitingResetCompleteRemoteInitiated);\n      } else {\n        // FIXME: This could be an UnsupportedError, we probably don't want to\n        // keep on trying to negotiate protocol\n        _control.enter(ControlStateAwaitingResetCompleteLocalInitiated);\n      }\n    },\n  };\n\n  var ControlTransitions = {\n    ControlStateDisconnected : function(from_state) {\n      _control.resetProtocol();\n      _control.state = ControlStateAwaitingResetCompleteRemoteInitiated;\n    },\n    ControlStateAwaitingResetCompleteRemoteInitiated : function(from_state) {\n      _control.resetProtocol();\n      _control.state = ControlStateAwaitingResetCompleteRemoteInitiated;\n      _controlSendResetComplete();\n    },\n    ControlStateAwaitingResetCompleteLocalInitiated : function(from_state) {\n      if (from_state != ControlStateAwaitingResetCompleteLocalInitiated) {\n        // Coming from elsewhere, send the ResetRequest\n        _controlSendResetRequest();\n      }\n      _control.resetProtocol();\n      _control.state = ControlStateAwaitingResetCompleteLocalInitiated;\n    },\n    ControlStateSessionOpen : function(from_state) {\n      _control.state = ControlStateSessionOpen;\n      _callHandlersForEvent('postmessageconnected');\n    },\n  };\n\n  var PROTOCOL = {\n    min_version : 1,\n    max_version : 1,\n    max_tx_chunk_size : 1000,\n    max_rx_chunk_size : 1000,\n  };\n\n  var _control = {\n    state : ControlStateDisconnected,\n    handle : function(msg) {\n      debugLog(\"Handle \" + this.state + \"(\" + JSON.stringify(msg.payload) + \"}\");\n      ControlHandlers[this.state](msg.payload);\n    },\n    enter : function(to_state) {\n      debugLog(\"Enter \" + this.state + \" ===> \" + to_state);\n      var prev_state = this.state;\n      ControlTransitions[to_state](this.state);\n      if (prev_state == ControlStateSessionOpen && to_state != ControlStateSessionOpen) {\n        _callHandlersForEvent('postmessagedisconnected');\n      }\n    },\n    isSessionOpen: function() {\n      return (this.state === ControlStateSessionOpen);\n    },\n    resetProtocol: function() {\n      this.protocol = {\n        version : 0,\n        tx_chunk_size : 0,\n        rx_chunk_size : 0,\n      };\n    },\n    protocol : {\n      version : 0,\n      tx_chunk_size : 0,\n      rx_chunk_size : 0,\n    },\n  };\n\n  __Pebble.addEventListener('appmessage', function(msg) {\n    _control.handle(msg);\n  });\n\n  __Pebble.addEventListener('ready', function(e) {\n    _control.enter(ControlStateAwaitingResetCompleteLocalInitiated);\n  });\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/kyleking/Library/Application Support/Pebble SDK/SDKs/4.3/sdk-core/pebble/common/include/_pkjs_message_wrapper.js\n// module id = 2\n// module chunks = 0","/*! https://mths.be/utf8js v2.1.2 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction checkScalarValue(codePoint) {\n\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t}\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tcheckScalarValue(codePoint);\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string) {\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, it’s not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol() {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString) {\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar utf8 = {\n\t\t'version': '2.1.2',\n\t\t'encode': utf8encode,\n\t\t'decode': utf8decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn utf8;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = utf8;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tvar object = {};\n\t\t\tvar hasOwnProperty = object.hasOwnProperty;\n\t\t\tfor (var key in utf8) {\n\t\t\t\thasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.utf8 = utf8;\n\t}\n\n}(this));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/kyleking/Library/Application Support/Pebble SDK/SDKs/4.3/~/utf8/utf8.js\n// module id = 3\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 4\n// module chunks = 0","// PebbleKit JS (pkjs)\n\nvar myAPIKey = 'bdecc599b3dc8bbf12ac58ccc6858d97';\n\nPebble.on('message', function(event) {\n  // Get the message that was passed\n  var message = event.data;\n\n  if (message.fetch) {\n    navigator.geolocation.getCurrentPosition(function(pos) {\n      var url = 'http://api.openweathermap.org/data/2.5/weather' +\n              '?lat=' + pos.coords.latitude +\n              '&lon=' + pos.coords.longitude +\n              '&appid=' + myAPIKey;\n\n      request(url, 'GET', function(respText) {\n        var cityData = JSON.parse(respText);\n        \n      });\n      console.log(\"Lat/Long url:\")\n      console.log(url)\n      // The URL must use the city ID or name and will not work for the Lat/Long (FYI)\n      //   http://bulk.openweathermap.org/sample/city.list.json.gz\n      url = \"http://api.openweathermap.org/data/2.5/weather?id=4773711&appid=\" + myAPIKey\n      http://api.openweathermap.org/data/2.1/find/city?lat=38.89&lon=-77.07=&cnt=1\n\n      request(url, 'GET', function(respText) {\n        var weatherData = JSON.parse(respText);\n\n        Pebble.postMessage({\n          'weather': {\n            // Convert from Kelvin\n            'celcius': Math.round(weatherData.main.temp - 273.15),\n            'fahrenheit': Math.round((weatherData.main.temp - 273.15) * 9 / 5 + 32),\n            'desc': weatherData.weather[0].main\n          }\n        });\n      });\n    }, function(err) {\n      console.error('Error getting location');\n    },\n    { timeout: 15000, maximumAge: 60000 });\n  } else {\n    Pebble.postMessage({\n      'weather': {\n        'celcius': 999,\n        'fahrenheit': 999,\n        'desc': \"Testing\"\n      }\n    });\n  }\n});\n\nfunction request(url, type, callback) {\n  var xhr = new XMLHttpRequest();\n  xhr.onload = function (e) {\n    // HTTP 4xx-5xx are errors:\n    if (xhr.status >= 400 && xhr.status < 600) {\n      console.error('Request failed with HTTP status ' + xhr.status + ', body: ' + this.responseText);\n      return;\n    }\n    callback(this.responseText);\n  };\n  xhr.open(type, url);\n  xhr.send();\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/pkjs/index.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}